# JBG_HS_Ch11_SelfTest

## SelfTest01

### SelfTest Problem

How does Java’s multithreading capability enable you to write more efficient programs?

### SelfTest Solution



---
---

## SelfTest02

### SelfTest Problem

Multithreading is supported by the _________ class and the ________ interface.

### SelfTest Solution



---
---

## SelfTest03

### SelfTest Problem

When creating a runnable object, why might you want to extend `Thread` rather than implement `Runnable`?

### SelfTest Solution



---
---

## SelfTest04

### SelfTest Problem

Show how to use `join()` to wait for a thread object called `MyThrd` to end.

### SelfTest Solution



---
---

## SelfTest05

### SelfTest Problem

Show how to set a thread called `MyThrd` to three levels above normal priority.

### SelfTest Solution



---
---

## SelfTest06

### SelfTest Problem

What is the effect of adding the `synchronized` keyword to a method?

### SelfTest Solution



---
---

## SelfTest07

### SelfTest Problem

The `wait()` and `notify()` methods are used to perform _______________________.

### SelfTest Solution



---
---

## SelfTest08

### SelfTest Problem

Change the `TickTock` class so that it actually keeps time. That is, have each *tick* take one half second, and each *tock* take one half second. Thus, each *tick­-tock* will take one second. (Don’t worry about the time it takes to switch tasks, etc.)

### SelfTest Solution



---
---

## SelfTest09

### SelfTest Problem

Why can’t you use `suspend()`, `resume()`, and `stop()` for new programs?

### SelfTest Solution



---
---

## SelfTest10

### SelfTest Problem

What method defined by `Thread` obtains the name of a thread?

### SelfTest Solution



---
---

## SelfTest11

### SelfTest Problem

What does `isAlive()` return?

### SelfTest Solution



---
---

## SelfTest12

### SelfTest Problem

On your own, try adding synchronization to the `Queue` class developed in previous chapters so that it is safe for multithreaded use.

### SelfTest Solution



---
---

